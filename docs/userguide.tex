\documentclass[12pt]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{tikz}

\title{fdfault Elastodynamic Rupture Code}
\author{Eric G. Daub \\
Center for Earthquake Research and Information \\
 {\tt egdaub@memphis.edu}}
\date{}

\begin{document}
\maketitle

\tableofcontents

\section{Description}

{\tt fdfault} is a finite difference code for numerical simulation of elastodynamic fracture and friction problems in 2 and 3 dimensions, principally those arising in study of dynamic earthquake rupture. The code solves the elastic or elastic-plastic wave equation in the bulk material, coupled to frictional failure on the fault and external boundary conditions.

\section{Governing Equations}

The code solves the elastodynamic wave equation in 2 or 3 dimensions, with either an elastic or viscoplastic bulk material. For a 3D continuum, momentum balance requires that
\begin{eqnarray}
\rho\frac{\partial v_x}{\partial t} &=& \frac{\partial \sigma_{xx}}{\partial x}+\frac{\partial \sigma_{xy}}{\partial y}+\frac{\partial \sigma_{xz}}{\partial z} \\
\rho\frac{\partial v_y}{\partial t} &=& \frac{\partial \sigma_{xy}}{\partial x}+\frac{\partial \sigma_{yy}}{\partial y}+\frac{\partial \sigma_{yz}}{\partial z} \\
\rho\frac{\partial v_z}{\partial t} &=& \frac{\partial \sigma_{xz}}{\partial x}+\frac{\partial \sigma_{yz}}{\partial y}+\frac{\partial \sigma_{zz}}{\partial z},
\end{eqnarray}
where $\rho$ is density. Additionally, a constitutive law relates the stresses to the deformations. For a homogeneous, isotropic elastic-plastic material, these take the form
\begin{equation}
\frac{\partial \sigma_{ij}}{\partial t} = L_{ijkl}\left(\dot{\epsilon}_{kl}-\dot{\epsilon}^{pl}_{kl}\right)
\end{equation}
where the elastic tensor is given by Hooke's Law for a homogeneous isotropic material
\begin{equation}
L_{ijkl}\dot{\epsilon}_{kl}=\lambda\delta_{ij}\frac{\partial v_k}{\partial x_k}+G\left(\frac{\partial v_i}{\partial x_j}+\frac{\partial v_j}{\partial x_i}\right).
\end{equation}
The elastic tensor includes two material parameters: $\lambda$ is the first Lam\'{e} parameter and $G$ is the shear modulus. Summation over repeated indices is implied. For an elastic material, $\dot{\epsilon}^{pl}_{ij}=0$, while for a viscoplastic material the plastic strains are determined by the Drucker-Prager viscoplastic flow rule described below. For 2D problems, the code can handle either in-plane ($v_x$, $v_y$, $\sigma_{xx}$, $\sigma_{xy}$, $\sigma_{yy}$ are nonzero) or anti-plane ($v_z$, $\sigma_{xz}$, $\sigma_{yz}$ are nonzero) problems, where all variables are functions of $x$ and $y$.

For Drucker-Prager Viscoplasticity, plastic flow occurs when stresses exceed the yield function $F(\sigma_{ij})$:
\begin{equation}
F(\sigma_{ij}) = \bar{\tau}-c+\mu\sigma_{kk}/3,
\end{equation}
where $\bar{\tau}=\sqrt{s_{ij}s_{ij}/2}$ is the second invariant of the deviatoric stress tensor $s_{ij}=\sigma_{ij}-(\sigma_{kk}/3)\delta_{ij}$, $c$ is related to the cohesion, and $\mu$ is related to the internal coefficient of friction. For viscoplasticity, flow is allowed to exceed the yield criterion according to
\begin{equation}
F(\sigma_{ij})=\Lambda\eta,
\end{equation}
where $\Lambda=\sqrt{2\dot{e}^{pl}_{ij}\dot{e}^{pl}_{ij}}$ is the equivalent plastic strain rate from the deviatoric plastic strain rate $\dot{e}^{pl}_{ij}=\dot{\epsilon}^{pl}_{ij}-(\dot{\epsilon}^{pl}_{kk}/3)\delta_{ij}$ and $\eta$ is a viscoplastic ``viscosity'' defining the time scale over which stresses can exceed the yield stress. If stresses are accumulated at a rate faster than the relaxation time of the viscoplastic material, the material behaves elastically, and the stress then decays towards the yield surface if no further stresses are applied.

The components of plastic flow are determined by
\begin{equation}
\dot{\epsilon}^{pl}_{ij}=\Lambda P_{ij}\left(\sigma_{ij}\right),
\end{equation}
with $P_{ij}(\sigma_{ij})=s_{ij}/(2\bar{\sigma})+(\beta/3)\delta_{ij}$, where the $\beta$ parameter determines the ratio of volumetric to plastic strain. Thus, viscoplastic materials are determined by $\rho$, $\lambda$, $G$, $c$, $\mu$, $\beta$, and $\eta$, while elastic materials require specification of $\rho$, $\lambda$, and $G$. Rate independent plasticity arises in the limit that $\eta \rightarrow 0$, though the equations become increasingly stiff in this limit and plastic strain can exhibit localization that is not resolved by the spatial grid in many problems.

The code can handle variable material properties, though the properties must be piecewise constant in an arbitrary number of blocks. The blocks must form a regular grid with conforming edges, though the block boundaries can have complex shapes, so this does not limit the ability of the code to handle complex earth structures. Blocks are coupled together through interfaces, which can either be locked or frictional. Locked interfaces require continuity of velocity and forces, while frictional interfaces allow for relative slip across the interface according to several possible friction laws:

\begin{itemize}
\item {\bf Frictionless interfaces} do not support shear stresses, so any stress applied to such interfaces result in shear slip.
\item {\bf Kinematic forcing} Allows for a forced rupture following a prescribed set of rupture times.
\item {\bf Slip weakening interfaces} follow a slip-dependent friction law, where the friction coefficient has static and dynamic values and transitions between the two according to a function that decreases linearly with slip. Slip weakening laws also allow for cohesion. Slip weakening can also be combined with kinematic forcing to nucleate a rupture.
\item {\bf Shear Transformation Zone (STZ) Theory interfaces} have a frictional strength that depends on the slip rate and a dynamic state variable representing the configurational disorder in the fault gouge.
\end{itemize}

In addition to these base friction laws, a future version of the code will allow you to specify arbitrary slip- or rate- and state-dependent friction laws through the Python module, which automatically generates the required source code for new friction laws.

External boundaries (i.e. boundaries not between two blocks) can have absorbing, free surface (traction-free), or rigid (velocity-free) boundary conditions.

\section{Numerical Details}

The code solves the above equations numerically using finite differences. The outer boundaries of each block is described by a series of 6 surfaces (4 curves in 2D), and each block is transformed from physical space to the unit cube (unit square in 2D). The governing equations are transformed as well, and the code solves the resulting problem on a structured grid using high order finite differences. The grid is generated using standard transfinite interpolation, and the required metric derivatives for solving the governing equations and applying boundary conditions are automatically calculated using finite differences. Grids between neighboring blocks must be conforming, though no other continuity condition is required across block interfaces. The grid must satisfy certain smoothness constraints (these are checked during the initialization steps in the code), though non-uniform grid spacing along interfaces is allowed, provided that the resulting grid meets the smoothness requirements. Boundary conditions at external boundaries and interfaces are applied in locally rotated normal/tangential coordinate systems.

The specific finite difference operators used exhibit a summation-by-parts property that mimics the properties of integration by parts. This allows for estimates of the energy dissipation rate of the numerical scheme. Boundary conditions are imposed weakly using the Simultaneous Approximation Term approach, and this combined with the summation by parts difference operators allows for a provably stable numerical scheme that matches the energy dissipation rate of the continuous problem. More details on the method can be found in the following papers:

The code allows for central finite difference operators that are globally second, third, fourth, fifth, or sixth order accurate. Time integration is performed with a low memory Runge-Kutta method, with either first, second, third, or fourth order accuracy in time.

The finite difference method is only applied to the elastic part of the problem. The plasticity equations are handled through an operator splitting procedure, where the elastic problem is solved first and then used as initial conditions for the plasticity problem. This is done using an implicit backward Euler method.

\section{Installation}

{\tt fdfault} requires a C++ compiler and an MPI distribution, though you can run the code on a single processor if you want. The code has mostly been tested with the GNU compiler and Open MPI. Parallelization is achieved through domain decomposition, with interprocessor communication occuring after each Runge-Kutta stage to populate ghost cells with the appropriate values. Python with Numpy is required if you want to use the Python module for setting up problems and generating the input files, with support for either Python 2 or 3. The code also includes Python (requires Numpy) and MATLAB scripts for loading simulation data.

To install from a source tarball, unpacking the tarball and compiling the code simply requires

\vspace{0.1in}
\noindent{\tt \$ tar -xzvf fdfault-v1.0.tar.gz\\
\$ cd fdfault/src\\
\$ make}

\vspace{0.1in}
\noindent If you are using a different compiler, you will need to change the appropriate shell variables in the Makefile for your configuration.

Alternatively, you can get the source code from the git repository:

\vspace{0.1in}
\noindent{\tt \$ git clone fdfault.git\\
\$ cd fdfault/src\\
\$ make}

\vspace{0.1in}
If using the git repository, you need to build the documentation yourself. This requires a \LaTeX\ distribution with a few standard packages, most notablly TikZ. To create the documentation:

\vspace{0.1in}
\noindent{\tt\$ cd fdfault/docs\\
\$ make}

\vspace{0.1in}
\noindent If you prefer a PDF of the documentation, it is available at \\
{\tt http://www.ceri.memphis.edu/people/egdaub/codes.html}.

\section{Setting Up Problems}

Problems are set up using text input files. The files have to follow specific formatting requirements because of how the parameters are read from the file. While it is fairly straightforward to create input files yourself for simple problems, the Python module allows for much more flexible creation of problems. If you intend to use the code to solve complex problems, becoming familiar with input using Python is highly recommended.

\subsection{Text Input Files}

Text input files contain multiple sections. With one exception, the order of the sections is not important~-- the file is read multiple times by various parts of the code, and each time the file is read the code starts from the beginning and scans through to find the appropriate section. Each section is designated by a text string {\tt [fdfault.<name>]}, where {\tt <name>} refers to which part of the code will be reading this section. If the code expects to find a certain section and it reaches the end of the text file without finding it, the code will abort. At minimum, the following sections are required to fully specify a problem:

\vspace{0.1in}
{\tt [fdfault.problem]

[fdfault.domain]

[fdfault.fields]

[fdfault.block000]

[fdfault.outputlist]

[fdfault.frontlist]}

\vspace{0.1in}
\noindent In addition to these sections, optional sections describe additional blocks and any interfaces. These include the following sections:

\vspace{0.1in}
\noindent{\tt [fdfault.interface0]

\noindent[fdfault.friction]

\noindent[fdfault.slipweak]

\noindent[fdfault.stz]}

\vspace{0.1in}
\noindent If the problem has more than one block or more than one interface, the sections are designated with the numeric value included in the section header.

\subsubsection{Problem}

A problem is specified under {\tt [fdfault.problem]}. The entries under this section are as follows:

\vspace{0.1in}
Problem Name \\
\indent Data where simulation output will be saved \\
\indent Number of time steps \\
\indent Time step size \\
\indent Total time \\
\indent Courant ratio \\
\indent Frequency at which status information is written to the terminal \\
\indent Runge-Kutta Order (integer 1-4)

\vspace{0.1in}
\noindent Most of these are straightforward. The main tricky part in this section is that you typically will only specify two of the four options for determining the time step. You are free to specify any two of these, with the exception of the time step and Courant ratio (the ratio between the grid spacing and the distance a wave travels in one time step). If you specify both the time step and Courant ratio, the code defaults to the given time step. If you specify more than two parameters, the code defaults to the total time and either the time step or the Courant ratio.

\subsubsection{Domain}

Details of the spatial domain are determined by the {\tt [fdfault.domain]} header. The following arguments are required:

\vspace{0.1in}
Number of dimensions (2 or 3) \\
\indent Rupture mode (only meaningful for 2D problems, but necessary for 3D problems) \\
\indent Number of grid points (3 integers, if 2D problem the third will be reset to 1) \\
\indent Number of blocks (3 integers, if 2D problem the third will be reset to 1) \\
\indent Number of grid points for each block in $x$-direction \\
\indent Number of grid points for each block in $y$-direction \\
\indent Number of grid points for each block in $z$-direction \\
\indent Number of interfaces \\
\indent Type of each interface (list of strings)\\
\indent Finite difference order (integer 2-6)\\
\indent Material type (elastic or plastic)

\vspace{0.1in}
\noindent For this section, the trickiest part is understanding how the blocks and sizes are set up. First, the number of grid points is specified (which must have a length of 3), and then the number of blocks in each dimension is specified (also must of of length 3). If the problem is 2D, then the third entry in each list will be reset to 1 if it is not already 1. Depending on these entries, the code expects the integers that follow to conform to a specific order. First comes the length of each block along the $x$-direction. The code expects the number of entries to match the number of blocks, and the sum of all entries must equal the total number of grid points along the $x$-direction. Similarly, the $y$ and $z$ directions are specified in the subsequent entries. While it is recommended that the entries for each direction are on separate lines, the spacing between entries, as well as the line spacing, are ignored when reading the input file.

After the block dimensions are set, the code reads the number of interfaces, followed by the interface types (it expects a number of strings corresponding to the number of interfaces). Again, line breaks are ignored. The type of each interface must be one of the following: {\tt locked}, {\tt frictionless}, {\tt slipweak}, or {\tt stz}.

The final two entries are fairly self explanatory, and determine the finite difference order (integer 2-6) and the material response (elastic or plastic).

\subsubsection{Fields}

The initial stress fields are set with the {\tt [fdfault.fields]} header. This section has two entries:

\vspace{0.1in}
Uniform initial stress tensor \\
\indent Filename for spatially heterogeneous initial stress tensor

\vspace{0.1in}
\noindent The uniform initial stress tensor is a list of 6 numbers, and the order is $\sigma_{xx}$, $\sigma_{xy}$, $\sigma_{xz}$, $\sigma_{yy}$, $\sigma_{yz}$, $\sigma_{zz}$). Components not involved in a 2D problem are in some cases used in the problem, particularly for anti-plane (mode 3) problems, where the in-plane normal stress components determine the compressive normal stresses acting on the fault. Line breaks are ignored.

If a heterogeneous stress tensor will be used, it is specified with a filename here. If no heterogeneous file is to be read, this entry should be {\tt none}. The file should contain a sequence of double precision binary floating point numbers (endianness should match the processor where the code will be run). Components are entered one at a time, with the number of entries matching the grid size using row major order (C order). For 2D mode 3 problems, the order is $\sigma_{xz}$, $\sigma_{yz}$. For 2D mode 2 problems, the order is $\sigma_{xx}$, $\sigma_{xy}$, $\sigma_{yy}$ (and for plasticity problems, $\sigma_{zz}$). For 3D problems, the order is the same as for the uniform stress tensor. Entering heterogeneous stresses is greatly simplified if you use the Python module.

\subsubsection{Block}

Each block has its own section in the input file, designated by {\tt [fdfault.blockXYZ]} for the block with indices $(X,Y,Z)$ (the code assumes zero indexing). For each block, the input file entries set the material properties, boundary conditions, and geometry. The input file must contain a header for each block in the simulation, and other block headers that do not match a block in the simulation are ignored. Order is not important. Specific entries are as follows:

\vspace{0.1in}
\indent Material properties \\
\indent Block lower left coordinate \\
\indent Block side lengths \\
\indent Block boundary conditions \\
\indent Block boundary filenames

\vspace{0.1in}
\noindent The number of entries expected in each item depends on the type of problem being solved, and are explained below.

The material properties are the density $\rho$, Lam\'{e} constant $\lambda$, and shear modulus $G$, and for plasticity problems the parameters defined in the yield function and flow rule. Order for the plasticity parameters is internal friction $\mu$, cohesion $c$, dilatancy $\beta$, and viscosity $\eta$.

The lower left coordinate of the block determines its location in space, and requires 2 numbers for 2D problems and 3 numbers for 3D problems. Similarly, the block side lengths require the same number of entries for 2D and 3D problems. These coordinate values are used to create any boundary surfaces that are not set through a file by creating rectangular surfaces (in 3D) and straight lines (in 2D) for the appropriate block sides. If all sides are given as a file, these entries are ignored in creating the grid, though they are still used in adding surface tractions to frictional faults and modifying friction parameters.

The block boundary conditions is a list of 4 boundary conditions for 2D problems, and 6 boundary conditions for 3D problems. Order is left, right, front, back, top, bottom (where top and bottom are only for 3D problems). Each boundary condition must be one of the following strings: {\tt absorbing} (no waves enter the domain), {\tt free} (traction free surface), {\tt rigid} (zero velocity), or {\tt none} (do not apply a boundary condition, used if block is coupled to another through an interface).

Boundaries that are defined via a filename derive their data from files that contain binary data, rather than assuming a rectangular block edge. This method can be used to create non-planar block surfaces. The number of entries and order is the same as for the boundary conditions. Each file must contain double precision floating point binary data, with all $x$ coordinates in row major (C) order, followed by all $y$ coordinates, and if a 3D problem, all $z$ coordinates. Endianness is set by the computer where the simulation will be run. When setting nonplanar boundaries, the surfaces must conform at their edges, and the code checks this during initialization. While you can easily create your own files for defining nonplanar boundaries, this is made much simpler with the Python module.

\subsubsection{Interfaces}

All interfaces are specified by a header with the form {\tt [fdfault.interfaceX]}, where $X$ determines the interface number (zero indexed). For problems with $n$ interfaces, the input file must contain an interface header for all $n$ interfaces, or you will get an error. Interface headers are followed by the following arguments:

\vspace{0.1in}
\indent Approximate normal direction \\
\indent Minus block indices \\
\indent Plus block indices \\

\vspace{0.1in}
\noindent First, the list defines the approximate normal direction of the interface in the simulation based on the simulation geometry. For rectangular blocks, this is the true normal direction of the block, while if the block has boundaries specified through a file the normal direction may not be completely in this direction, or the normal direction may not be uniform across the entire block. The direction is set by a string {\tt x}, {\tt y}, or {\tt z}.

Following the direction specification, you must set the indices of the block on the ``minus'' side of the interface (a list of 3 integers). This can be any block in the simulation, but must be the block with the lowest set of indices that are joined by this interface. Order is not important for setting up the interfaces~-- interface 0 can join any pair of neighboring blocks in the simulation~-- and the lists can appear in the input file in any order.

Next, the block on the ``plus'' side of the interface is given by its indices. Because the blocks in the simulation must form a regular grid, the ``plus'' block must differ in only one index from the ``minus'' block, and the index that is different must be the same as the direction specified above (this is checked by the code when initializing). For instance, if the minus block is $(0,0,0)$, and the direction is {\tt x}, then the plus block must have the index $(1,0,0)$. Line breaks are ignored when reading in the indices.

\subsubsection{Frictional interfaces}

The information above is all that is required for locked interfaces. For frictional interfaces, additional information must be provided. All frictional interfaces must include a {\tt [fdfault.friction]} header somewhere {\em after} the interface header. Note that the friction header does not include an interface number~-- the code scans through the input file to find the interface header for the interface in question, and then continues scanning until it finds the next friction header. This trick lets you easily set multiple frictional interfaces to have the same specifications.

Friction headers contain the following information:

\vspace{0.1in}
\indent Number of load perturbations \\
\indent List of load perturbations \\
\indent Load perturbation filename \\

\vspace{0.1in}
\noindent First is an integer that determines the number of surface traction perturbations that will be applied to the interface during the simulation. Next is a list of perturbations, which have the following format:

\vspace{0.1in}
{\tt type t0 x0 dx y0 dy s1 s2 s3}

\vspace{0.1in}
\noindent {\tt type} is a string that determines the spatial characteristics of the perturbation. Options are {\tt constant} (spatially uniform), {\tt boxcar} (spatially uniform inside a rectangular area, zero outside), {\tt ellipse} (spatially uniform inside an elliptical area, zero outside), and {\tt linear} (linear function in each direction).

{\tt t0} determines the time scale over which the perturbation is added, with a linear ramp from zero over the given time scale. If the perturbation is to be added from the start of the simulation, give 0.

{\tt x0 dx} are constants determining the shape of the perturbation along first coordinate direction of the interface ($x$ for {\tt y} and {\tt z} interfaces, $y$ for {\tt x} interfaces). For constant perturbations, these parameters are ignored. For boxcar and ellipse perturbations, {\tt x0} is the center of the perturbation and {\tt dx} is the half width. If you want the width to span the entire interface width, enter 0 for {\tt dx}. For linear perturbations, {\tt x0} is the intercept and {\tt dx} is the slope. If you want the linear gradient to only extend in one direction, enter 0 for {\tt dx}. Similarly, {\tt y0 dy} set the same values for the other coordinate direction ($y$ for {\tt z} interfaces and $z$ for {\tt x} and {\tt y} interfaces). For 2D problems, the second set of indices is ignored, but still must be present in the input file.

In the simulations, the values of {\tt x0 dx y0 dy} are only interpreted literally for rectangular blocks. For non-rectangular blocks, these values are interpreted assuming the interface follows a rectangular block on the minus side, using the values given under the block header. This means that the values may not be interpreted exactly as you expect!

Finally, a trio of numbers set the vector surface traction applied to the interface. The first component is the normal traction, and the next two numbers are the two shear tractions. For 2D problems, the code sets the appropriate shear traction component to zero. For 3D problems, the exact meaning of the shear traction components are determined by the surface normal direction.

After all of the surface traction perturbations, the code takes a filename of a file that adds additional tractions to the surface. The file contains a series of double precision floating point binary numbers of length $3\times n1 \times n2$, where $n1$ and $n2$ are the number of grid points along the interface. The first block of $n1\times n2$ is for the normal traction (in row major order), then the first shear traction component, and finally the second shear traction component. Endianness is assumed to match the computer where the simulation is being run.

\subsubsection{Example}

To illustrate how to specify each section, here is an example problem {\tt test2d.in} (included in the {\tt problems} directory)

\vspace{0.1in}
\noindent{\tt [fdfault.problem] \\
test2d \\
data/ \\
500 \\
0 \\
0 \\
0.3 \\
50 \\
4 \\

\vspace{0.25em}
\noindent [fdfault.domain] \\
2 \\
2 \\
401 402 1 \\
1 2 1 \\
401 \\
201 201 \\
1 \\
1 \\
slipweak \\
4 \\
elastic \\

\vspace{0.25em}
\noindent [fdfault.fields] \\
0. 0. 0. 0. 0. 0. \\
none \\

\vspace{0.25em}
\noindent [fdfault.block000] \\
2.67 32.04 32.04 \\
0. 0. \\
40. 20. \\
absorbing \\
absorbing \\
absorbing \\
none \\
none \\
none \\
none \\
none \\

\vspace{0.25em}
\noindent [fdfault.block010] \\
2.67 32.04 32.04 \\
0. 20. \\
40. 20. \\
absorbing \\
absorbing \\
none \\
absorbing \\
none \\
none \\
none \\
none \\

\vspace{0.25em}
\noindent [fdfault.interface0] \\
y \\
0 0 0 \\
0 1 0 \\

\vspace{0.25em}
\noindent [fdfault.friction] \\
2 \\
constant 0. 0. 0. 0. 0. -120. 70. 0. \\
boxcar 0. 20. 1.5 0. 0. 0. 11.6 0. \\
none \\

\vspace{0.25em}
\noindent [fdfault.slipweak] \\
3 \\
constant 0. 0. 0. 0. 0. 0.4 0.677 0.525 0. 0. 0. \\
boxcar 0. 2.5 2.5 0. 0. 0. 0. 0. 0. 0. 0. \\
boxcar 0. 37.5 2.5 0. 0. 0. 0. 0. 0. 0. 0. \\
none \\

\vspace{0.25em}
\noindent [fdfault.outputlist] \\
Vx \\
Vx \\
0 500 1 \\
0 400 1 \\
201 201 1 \\
0 0 1 \\
Sx \\
Sx \\
0 500 1 \\
0 400 1 \\
201 201 1 \\
0 0 1 \\
Ux \\
Ux \\
0 500 1 \\
0 400 1 \\
201 201 1 \\
0 0 1 \\

\vspace{0.25em}
\noindent [fdfault.frontlist] \\
0}



\subsection{Python Scripts}

\subsection{Included Example Problems}

\section{Analysis with Python or MATLAB}

\end{document}  